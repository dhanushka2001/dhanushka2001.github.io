<!DOCTYPE html><html lang="en"> <head><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Cross-Language Interoperability: Exploring Rust&#39;s FFI, WebAssembly, and gRPC - Dhanushka&#39;s Blog</title><meta name="description" content="In this article, we will explore three techniques for cross-language interoperability: Rust's FFI, WebAssembly, and gRPC."><meta name="author" content="Dhanushka Jayagoda"><link rel="alternate" type="application/rss+xml" href="/rss.xml"><link rel="icon" type="image/x-icon" href="/favicon.ico"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2479144310234386" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-119155027-6"></script><script type="text/javascript">
      let slideIndex = 1;
      showSlides(slideIndex);

      function plusSlides(n) {
        showSlides((slideIndex += n));
      }

      function currentSlide(n) {
        showSlides((slideIndex = n));
      }

      function showSlides(n) {
        try {
          let i;
          let slides = document.getElementsByClassName('mySlides');
          let dots = document.getElementsByClassName('demo');
          let captionText = document.getElementById('caption');
          if (n > slides.length) {
            slideIndex = 1;
          }
          if (n < 1) {
            slideIndex = slides.length;
          }
          for (i = 0; i < slides.length; i++) {
            slides[i].style.display = 'none';
          }
          for (i = 0; i < dots.length; i++) {
            dots[i].className = dots[i].className.replace(' active', '');
          }
          slides[slideIndex - 1].style.display = 'block';
          dots[slideIndex - 1].className += ' active';
          captionText.innerHTML = dots[slideIndex - 1].alt;
        } catch (err) {
          // do nothing here
        }
      }
    </script><!-- Google Tag Manager --><!-- End Google Tag Manager --><link rel="stylesheet" href="/_astro/index.BsaAxKtc.css" />
<style>.astro-route-announcer{position:absolute;left:0;top:0;clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}@media print{.no-print,.no-print *{display:none!important}}
</style><script type="module" src="/_astro/hoisted.UksxmqGZ.js"></script></head> <body class="bg-slate-900 text-gray-100"> <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-K8P5P8FQ" height="0" width="0" style="display:none;visibility:hidden"></iframe> </noscript> <!-- End Google Tag Manager (noscript) --> <div class="mx-auto max-w-screen-lg px-3 py-6"><div class="flex flex-col gap-y-3 sm:flex-row sm:items-center sm:justify-between"><a href="/"><div class="flex items-center bg-gradient-to-br from-sky-500 to-cyan-400 bg-clip-text text-xl font-bold text-transparent"><svg class="mr-1 h-10 w-10 stroke-cyan-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M0 0h24v24H0z" stroke="none"></path><rect x="3" y="12" width="6" height="8" rx="1"></rect><rect x="9" y="8" width="6" height="12" rx="1"></rect><rect x="15" y="4" width="6" height="16" rx="1"></rect><path d="M4 20h14"></path></svg>Dhanushka&#x27;s Blog</div></a><nav><ul class="flex gap-x-3 font-medium text-gray-200"><li class="hover:text-white"><a href="/posts">Blogs</a></li><li class="hover:text-white"><a href="https://github.com/dhanushka2001/blog-astro">GitHub</a></li><li class="hover:text-white"><a href="/photos">Photos</a></li></ul></nav></div></div> <div data-pagefind-body>  <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var d=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var u;{let c={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(u=class extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},l=this.querySelectorAll("template[data-astro-template]");for(let o of l){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let h;try{h=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=` (export ${b})`),console.error(`[hydrate] Error parsing props for component ${i}`,this.getAttribute("props"),o),o}let p;await this.hydrator(this)(this.Component,h,r,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(`astro:${n}`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[l,{default:h}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),p=this.getAttribute("component-export")||"default";if(!p.includes("."))this.Component=l[p];else{this.Component=l;for(let y of p.split("."))this.Component=this.Component[y]}return this.hydrator=h,this.hydrate},e,this)}catch(r){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,r)}}attributeChangedCallback(){this.hydrate()}},d(u,"observedAttributes",["props"]),u))}})();</script><astro-island uid="Z2mJqul" prefix="r2" component-url="/_astro/BlogPost.BdPqyukv.js" component-export="default" renderer-url="/_astro/client.D9Vng9vH.js" props="{&quot;frontmatter&quot;:[0,{&quot;title&quot;:[0,&quot;Cross-Language Interoperability: Exploring Rust&#39;s FFI, WebAssembly, and gRPC&quot;],&quot;description&quot;:[0,&quot;In this article, we will explore three techniques for cross-language interoperability: Rust&#39;s FFI, WebAssembly, and gRPC.&quot;],&quot;pubDate&quot;:[0,&quot;Saturday, 27 December 2024 13:00:00 GMT&quot;],&quot;tags&quot;:[1,[[0,&quot;rust&quot;],[0,&quot;ffi&quot;]]],&quot;imgSrc&quot;:[0,&quot;/imgs/2023/117117315.png&quot;],&quot;authors&quot;:[1,[[0,&quot;David Li&quot;]]],&quot;file&quot;:[0,&quot;/home/runner/work/blog-astro/blog-astro/src/pages/posts/tech/rust/rust_cross_language.md&quot;],&quot;url&quot;:[0,&quot;/posts/tech/rust/rust_cross_language&quot;]}]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;BlogPost&quot;,&quot;value&quot;:true}" await-children=""><div class="mx-auto max-w-screen-lg px-3 py-6"><div><h1 class="text-center text-3xl font-bold">Cross-Language Interoperability: Exploring Rust&#x27;s FFI, WebAssembly, and gRPC</h1><div class="text-center text-sm text-gray-400"><div class="mt-1">Published:<!-- --> <!-- -->Dec 27, 2024</div><div class="mt-2 flex flex-wrap items-center justify-center gap-4"><div class="flex items-center space-x-2"><img src="/assets/images/avatars/david.png" alt="David Li" class="h-6 w-6 rounded-full object-cover" loading="lazy"/><a href="https://github.com/FriendlyUser" target="_blank" rel="noopener noreferrer" class="hover:underline">David Li</a></div></div></div><div class="flex place-content-center pt-2"><div class="rounded-md px-2 py-1 text-xs font-semibold bg-cyan-400 text-cyan-900"> <a href="/tags/rust" style="padding-right:3px"> <category>rust<!-- --> </category></a></div> <div class="rounded-md px-2 py-1 text-xs font-semibold bg-cyan-400 text-cyan-900"> <a href="/tags/ffi" style="padding-right:3px"> <category>ffi<!-- --> </category></a></div> </div><div class="mx-auto mt-5 max-w-prose"><div class="aspect-h-2 aspect-w-3"><img class="h-full w-full rounded-lg object-cover object-center" src="/imgs/2023/117117315.png" loading="lazy"/></div><div class="prose prose-invert mt-6 prose-img:rounded-lg"><content><astro-slot> <p>Cross-Language Interoperability: Exploring Rust’s FFI, WebAssembly, and gRPC</p>
<p>In today’s world of software development, it’s not uncommon to encounter projects that involve multiple programming languages. While each language has its strengths and weaknesses, combining multiple languages can provide a more powerful and flexible solution. However, integrating multiple languages can be challenging due to differences in syntax, data types, and memory management. In this article, we will explore three techniques for cross-language interoperability: Rust’s FFI, WebAssembly, and gRPC.</p>
<p>Rust’s FFI</p>
<p>Rust’s Foreign Function Interface (FFI) allows Rust code to call functions defined in other programming languages, such as C or C++. This is accomplished by defining an external function in Rust with a C-compatible function signature, and then dynamically linking to a shared library that contains the function implementation. Here’s an example of calling a C function from Rust using FFI:</p>
<pre class="astro-code monokai" style="background-color:#272822;color:#F8F8F2; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#66D9EF;font-style:italic">extern</span><span style="color:#E6DB74"> "C"</span><span style="color:#F8F8F2"> {</span></span>
<span class="line"><span style="color:#F92672">    fn</span><span style="color:#A6E22E"> my_c_function</span><span style="color:#F8F8F2">(arg1</span><span style="color:#F92672">:</span><span> </span><span style="color:#A6E22E;text-decoration:underline">i32</span><span style="color:#F8F8F2">, arg2</span><span style="color:#F92672">:</span><span> </span><span style="color:#A6E22E;text-decoration:underline">f64</span><span style="color:#F8F8F2">) </span><span style="color:#F92672">-></span><span> </span><span style="color:#A6E22E;text-decoration:underline">f64</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672">fn</span><span style="color:#A6E22E"> main</span><span style="color:#F8F8F2">() {</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic">    let</span><span style="color:#F8F8F2"> result </span><span style="color:#F92672">=</span><span style="color:#F92672"> unsafe</span><span style="color:#F8F8F2"> { </span><span style="color:#A6E22E">my_c_function</span><span style="color:#F8F8F2">(</span><span style="color:#AE81FF">42</span><span style="color:#F8F8F2">, </span><span style="color:#AE81FF">3.14</span><span style="color:#F8F8F2">) };</span></span>
<span class="line"><span style="color:#A6E22E">    println!</span><span style="color:#F8F8F2">(</span><span style="color:#E6DB74">"Result: {}"</span><span style="color:#F8F8F2">, result);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>While Rust’s FFI is powerful and flexible, it does require some knowledge of low-level programming concepts, such as pointers and memory management. Additionally, it only supports communication between languages that can produce C-compatible object code.</p>
<p>WebAssembly</p>
<p>WebAssembly is a binary format for executing code on the web, designed to be a low-level target for programming languages. It provides a portable and efficient way to run code in a web browser, and can also be used outside of the web as a standalone platform. WebAssembly is designed to be compatible with multiple programming languages, including Rust, C++, and JavaScript.</p>
<p>To use WebAssembly, a program is compiled to WebAssembly bytecode, which can then be executed in a virtual machine. The bytecode can be generated from various programming languages using compilers, such as Rust’s wasm-pack. Here’s an example of calling a Rust function from JavaScript using WebAssembly:</p>
<pre class="astro-code monokai" style="background-color:#272822;color:#F8F8F2; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F8F8F2">#[no_mangle]</span></span>
<span class="line"><span style="color:#F92672">pub</span><span style="color:#F92672"> fn</span><span style="color:#A6E22E"> add</span><span style="color:#F8F8F2">(a</span><span style="color:#F92672">:</span><span> </span><span style="color:#A6E22E;text-decoration:underline">i32</span><span style="color:#F8F8F2">, b</span><span style="color:#F92672">:</span><span> </span><span style="color:#A6E22E;text-decoration:underline">i32</span><span style="color:#F8F8F2">) </span><span style="color:#F92672">-></span><span> </span><span style="color:#A6E22E;text-decoration:underline">i32</span><span style="color:#F8F8F2"> {</span></span>
<span class="line"><span style="color:#F8F8F2">    a </span><span style="color:#F92672">+</span><span style="color:#F8F8F2"> b</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<pre class="astro-code monokai" style="background-color:#272822;color:#F8F8F2; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#A6E22E">fetch</span><span style="color:#F8F8F2">(</span><span style="color:#E6DB74">'add.wasm'</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">  .</span><span style="color:#A6E22E">then</span><span style="color:#F8F8F2">(</span><span style="color:#FD971F;font-style:italic">response</span><span style="color:#66D9EF;font-style:italic"> =></span><span style="color:#F8F8F2"> response.</span><span style="color:#A6E22E">arrayBuffer</span><span style="color:#F8F8F2">())</span></span>
<span class="line"><span style="color:#F8F8F2">  .</span><span style="color:#A6E22E">then</span><span style="color:#F8F8F2">(</span><span style="color:#FD971F;font-style:italic">bytes</span><span style="color:#66D9EF;font-style:italic"> =></span><span style="color:#F8F8F2"> WebAssembly.</span><span style="color:#A6E22E">instantiate</span><span style="color:#F8F8F2">(bytes))</span></span>
<span class="line"><span style="color:#F8F8F2">  .</span><span style="color:#A6E22E">then</span><span style="color:#F8F8F2">(</span><span style="color:#FD971F;font-style:italic">results</span><span style="color:#66D9EF;font-style:italic"> =></span><span style="color:#F8F8F2"> {</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic">    const</span><span style="color:#F8F8F2"> add </span><span style="color:#F92672">=</span><span style="color:#F8F8F2"> results.instance.exports.add;</span></span>
<span class="line"><span style="color:#F8F8F2">    console.</span><span style="color:#A6E22E">log</span><span style="color:#F8F8F2">(</span><span style="color:#A6E22E">add</span><span style="color:#F8F8F2">(</span><span style="color:#AE81FF">2</span><span style="color:#F8F8F2">, </span><span style="color:#AE81FF">3</span><span style="color:#F8F8F2">)); </span><span style="color:#88846F">// Output: 5</span></span>
<span class="line"><span style="color:#F8F8F2">  });</span></span></code></pre>
<p>WebAssembly provides a high degree of portability and security, as the code runs in a sandboxed environment with restricted access to the host system. However, it does have some limitations, such as limited access to the browser’s APIs and the inability to directly access the host system’s file system.</p>
<p>gRPC</p>
<p>gRPC is a high-performance, open-source framework for building remote procedure call (RPC) systems. It allows communication between services written in different programming languages using a language-agnostic protocol called Protocol Buffers. gRPC supports multiple programming languages, including Rust, C++, Java, and Python, among others.</p>
<p>To use gRPC, a service is defined using Protocol Buffers, which describes the data structures and methods that can be called remotely. A client and server can then be generated from the service definition, which can communicate with each other using the gRPC protocol. Here’s an example of defining a gRPC service in Rust:</p>
<pre class="astro-code monokai" style="background-color:#272822;color:#F8F8F2; overflow-x: auto;" tabindex="0"><code><span class="line"><span>syntax = "proto3";</span></span>
<span class="line"><span></span></span>
<span class="line"><span>package hello;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>service Greeter {</span></span>
<span class="line"><span>  rpc SayHello (HelloRequest) returns (HelloReply) {}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message HelloRequest {</span></span>
<span class="line"><span>  string name = 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message HelloReply {</span></span>
<span class="line"><span>  string message = 1;</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>gRPC provides a high degree of flexibility and performance, as it uses a binary protocol that is optimized for low latency and high throughput. Additionally, it provides features such as authentication, load balancing, and error handling out of the box. However, it does require some setup and configuration to get started, and may not be suitable for all use cases.</p>
<p>Conclusion</p>
<p>Cross-language interoperability is an important aspect of modern software development, as it allows different programming languages to work together to create more powerful and flexible solutions. Rust’s FFI, WebAssembly, and gRPC are just a few examples of techniques and technologies that can be used for cross-language communication. By understanding these tools, developers can leverage the strengths of multiple languages to create better software.</p> </astro-slot></content></div></div></div></div><!--astro:end--></astro-island>  </div> <div class="mx-auto max-w-screen-lg px-3 py-6"><div class="no-print border-t border-gray-600 pt-5"><div class="text-sm text-gray-200">© Copyright <!-- -->2025<!-- --> by <!-- -->Dhanushka&#x27;s Blog<!-- -->. Built with ♥ by<!-- --> <a class="text-cyan-400 hover:underline" href="https://github.com/dhanushka2001" target="_blank" rel="noopener noreferrer">Dhanushka</a>. Last updated on <!-- -->2025-07-08<!-- -->.</div></div><script src="https://cdn.botpress.cloud/webchat/v0/inject.js"></script><script src="https://mediafiles.botpress.cloud/0df54034-3318-451a-aed0-3923a4ee25a5/webchat/config.js" defer=""></script></div> </body></html>